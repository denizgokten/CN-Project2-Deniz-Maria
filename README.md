# CN-Project2-Deniz-Maria


We have built a comprehensive implementation of TCP using a sender and a receiver. It includes the demonstrations of a reliable data transfer and a congestion control protocol. The sender also generates an output CSV file called CWND where it inputs the window size at different times. The file is first updated when the protocol starts where the window size equals to 1. From there the sender continues to update it each time the window size changes.

The sender starts by buffering the input data file into packets and stores them in a linked list. As it sends the first packet over to the receiver, it starts a timer for the packet that is implemented over a sliding window mechanism. There is a fixed amount of time it waits for an ACK, which the receiver sends as the next packet it expects to receive after receiving the previous one. 

On the receiver side, we used a linked list for the implementation of receiving packets. As the receiver receives a packet, first checks if the sequence number of the packet matches the expected number. If it matches, it's sent to be added to the cache through the function add_to_cache. Inside the function, deep copies of the packets are made and stored by their sequence numbers in an ascending order in the cache into a linked list. After, the receiver calls the write_from_cache function where the packets from the cache are written into a file in order and then freed. Finally, the receiver sends an ACK to the server with the sequence number of the next packet it's expecting to receive.

For dealing with packets that weren't transmitted, the sender uses two methods to check. The first one is if the fixed amount of time is passed and timer expired after sending the packet and no ACK was sent back, the sender resends that packet. The second way is if the sender receives 3 duplicate ACKs in a row, it considers the packet as lost and sends a signal to resend the packets. Resending is handled by the resend_packets function which first checks for a timeout of triple ACK, then resends the packet. It also sets the ssthresh value to max(current_window_size/2,2) and sets the window size to 1 if it wasn't already. 

On the receiver side, these out-of-sequence packets are buffered by being added to the cache buffer without writing on it. Afterward, a duplicate ACK is sent back to the server for the next packet it's expecting to receive.

For the congestion control mechanism, we have implemented slow start, congestion avoidance, and fast retransmit. The window size here is dynamic in accordance to what the sender determines, and is by default set to 1 for the initial packet. As the sender receives ACKs, the window size is increased by one packet and keeps getting increased until a loss is detected for it reaches the value ssthresh (initially set to 64 packets). After that, congestion avoidance begins. For the lost packets, ssthresh is reset to max(current_window_size/2,2). In congestion avoidance mode, window size is increased slower, by a fraction equal to 1/CWND. If 3 duplicate ACKs are received, the sender takes the ACK no. as the sequenco no. of the packet that was lost and starts fast retransmit. Then ssthresh is once again set to max(current_window_size/2,2), and the window size is set to 1, after which the slow start mechanism restarts. 
